#include <Modules/viewer/Viewer3D.h>

Viewer3D::Viewer3D(){
    this->_isConfigured = false;
    this->_name = consts::VEWER3D;
}

Viewer3D::~Viewer3D(){

}

int Viewer3D::config(string filename){
    if(LOG_VIEWER_3D){cout << "Viewer3D::config(): Start...\n";}

    if(!filename.empty()){
        if(_viewerSettings.read(filename) != 0){
            cerr << " Viewer3D::config(): Error on read settings!\n";
            return -1;
        }
        if(_viewerSettings.interprate() != 0){
            cerr << " Viewer3D::config(): Error on interprate!\n";
            return -1;
        }

        if(_loadCameraParameters() != 0){
            cerr << "Viewer3D::config(): Error on _loadCameraParameters!\n";
            return -1;
        }

        _isConfigured = true;
    }

    if(LOG_VIEWER_3D){cout << "Viewer3D::config(): Finish_OK!\n";}
    return 0;
}

int Viewer3D::run(){
    if(LOG_VIEWER_3D){cout << "Viewer3D::run(): Start...\n";}

    if(!_isConfigured){
        std::cerr << "Viewer3D::run(): Module not configured! Please Configure First!\n";
        return -1;
    }

    reprojectImageTo3D(dispMap, mesh3D, _Q);

    if(LOG_VIEWER_3D){cout << "Viewer3D::run(): Finish_OK!\n";}
    return 0;
}


void Viewer3D::setQMatrix(Mat Q){
     Q.copyTo(this->_Q);
}

Mat Viewer3D::getQMatrix(void){
    return this->_Q;
}


int Viewer3D::writePlyFile(std::string filename, Mat mesh3D)
{

    std::vector<float> verts;
    std::vector<float> norms;
    std::vector<uint8_t> colors;

    std::vector<int32_t> vertexIndicies;
    std::vector<float> faceTexcoords;

    // Per-vertex elements
    verts = {
        0.f, 1.f, 2.f,
        3.f, 4.f, 5.f,
        6.f, 7.f, 8.f,
        9.f, 10.f, 11.f,
        12.f, 13.f, 14.f,
        15.f, 16.f, 17.f,
        18.f, 19.f, 20.f,
        21.f, 22.f, 23.f,
        24.f, 25.f, 26.f,
        27.f, 28.f, 29.f,
        30.f, 31.f, 32.f,
        33.f, 34.f, 35.f,
    };

    norms = {
        0.5f, 1.5f, 2.5f,
        3.5f, 4.5f, 5.5f,
        6.5f, 7.5f, 8.5f,
        9.5f, 10.5f, 11.5f,
        12.5f, 13.5f, 14.5f,
        15.5f, 16.5f, 17.5f,
        18.5f, 19.5f, 20.5f,
        21.5f, 22.5f, 23.5f,
        24.5f, 25.5f, 26.5f,
        27.5f, 28.5f, 29.5f,
        30.5f, 31.5f, 32.5f,
        33.5f, 34.5f, 35.5f,
    };

    colors = {
        10, 20, 30, 244,
        15, 25, 35, 245,
        20, 30, 40, 246,
        25, 35, 45, 247,
        30, 40, 50, 248,
        35, 45, 55, 249,
        40, 50, 60, 250,
        45, 55, 65, 251,
        50, 60, 70, 252,
        55, 65, 75, 253,
        60, 70, 80, 254,
        65, 75, 85, 255
    };

    // Per-face elements
    vertexIndicies = {
        0, 1, 2,
        3, 4, 5,
        6, 7, 8,
        9, 10, 11
    };

    faceTexcoords = {
        0.25f, 0.55f,
        0.26f, 0.56f,
        0.27f, 0.57f,
        0.28f, 0.58f,
        0.29f, 0.59f,
        0.30f, 0.60f,
        0.31f, 0.61f,
        0.32f, 0.62f,
        0.33f, 0.63f,
        0.34f, 0.64f,
        0.35f, 0.65f,
        0.36f, 0.66f
    };

    const std::string fileNameBuff = filename;

    // Tinyply does not perform any file i/o internally
    std::filebuf fb;
    fb.open(fileNameBuff, std::ios::out | std::ios::binary);
    std::ostream outputStream(&fb);

    PlyFile OutFile;

    OutFile.add_properties_to_element("vertex", { "x", "y", "z" }, Type::FLOAT32, verts.size(), reinterpret_cast<uint8_t*>(verts.data()), Type::INVALID, 0);
    OutFile.add_properties_to_element("vertex", { "nx", "ny", "nz" }, Type::FLOAT32, verts.size(), reinterpret_cast<uint8_t*>(norms.data()), Type::INVALID, 0);
    OutFile.add_properties_to_element("vertex", { "red", "green", "blue", "alpha" }, Type::UINT8, verts.size(), reinterpret_cast<uint8_t*>(colors.data()), Type::INVALID, 0);

    OutFile.add_properties_to_element("face", { "vertex_indices" }, Type::UINT32, vertexIndicies.size(), reinterpret_cast<uint8_t*>(vertexIndicies.data()), Type::UINT16, 3);
    OutFile.add_properties_to_element("face", { "texcoord" }, Type::FLOAT32, faceTexcoords.size(), reinterpret_cast<uint8_t*>(faceTexcoords.data()), Type::UINT16, 6);

    OutFile.get_comments().push_back("generated by tinyply");
    OutFile.write(outputStream, false);

    fb.close();
    return 0;
}

int Viewer3D::readPlyFile(std::string filename)
{
    try
    {
        // Read the file and create a std::istringstream suitable
        // for the lib -- tinyply does not perform any file i/o.
        std::ifstream ss(filename, std::ios::binary);

        if (ss.fail())
        {
            throw std::runtime_error("failed to open " + filename);
        }

        PlyFile file;

        file.parse_header(ss);

        std::cout << "================================================================\n";

        for (auto c : file.get_comments()) std::cout << "Comment: " << c << std::endl;

        for (auto e : file.get_elements())
        {
            std::cout << "element - " << e.name << " (" << e.size << ")" << std::endl;
            for (auto p : e.properties)
            {
                std::cout << "\tproperty - " << p.name << " (" << tinyply::PropertyTable[p.propertyType].str << ")" << std::endl;
            }
        }

        std::cout << "================================================================\n";

        // Tinyply 2.0 treats incoming data as untyped byte buffers. It's now
        // up to users to treat this data as they wish. See below for examples.
        std::shared_ptr<PlyData> vertices, normals, colors, faces, texcoords;

        // The header information can be used to programmatically extract properties on elements
        // known to exist in the file header prior to reading the data. For brevity of this sample, properties
        // like vertex position are hard-coded:
        try { vertices = file.request_properties_from_element("vertex", { "x", "y", "z" }); }
        catch (const std::exception & e) { std::cerr << "tinyply exception: " << e.what() << std::endl; }

        try { normals = file.request_properties_from_element("vertex", { "nx", "ny", "nz" }); }
        catch (const std::exception & e) { std::cerr << "tinyply exception: " << e.what() << std::endl; }

        try { colors = file.request_properties_from_element("vertex", { "red", "green", "blue", "alpha" }); }
        catch (const std::exception & e) { std::cerr << "tinyply exception: " << e.what() << std::endl; }

        try { faces = file.request_properties_from_element("face", { "vertex_indices" }); }
        catch (const std::exception & e) { std::cerr << "tinyply exception: " << e.what() << std::endl; }

        try { texcoords = file.request_properties_from_element("face", { "texcoord" }); }
        catch (const std::exception & e) { std::cerr << "tinyply exception: " << e.what() << std::endl; }

        //manual_timer read_timer;

        //read_timer.start();
        file.read(ss);
        //read_timer.stop();

        // Good place to put a breakpoint!
        //std::cout << "Parsing took " << read_timer.get() / 1000.f << " seconds: " << std::endl;

        if (vertices) std::cout << "\tRead " << vertices->count << " total vertices "<< std::endl;
        if (normals) std::cout << "\tRead " << normals->count << " total vertex normals " << std::endl;
        if (colors) std::cout << "\tRead " << colors->count << " total vertex colors "<< std::endl;
        if (faces) std::cout << "\tRead " << faces->count << " total faces (triangles) " << std::endl;
        if (texcoords) std::cout << "\tRead " << texcoords->count << " total texcoords " << std::endl;

        // Example: type 'conversion' to your own native types - Option A
        {
            const size_t numVerticesBytes = vertices->buffer.size_bytes();
            struct float3 { float x, y, z; };
            std::vector<float3> verts(vertices->count);
            std::memcpy(verts.data(), vertices->buffer.get(), numVerticesBytes);
        }

        // Example: type 'conversion' to your own native types - Option B
        {
            const size_t numVerticesBytes = vertices->buffer.size_bytes();
            struct float3 { float x, y, z; };
            struct double3 { double x, y, z; };

            std::vector<float3> verts_floats;
            std::vector<double3> verts_doubles;

            if (vertices->t == tinyply::Type::FLOAT32) { /* as floats ... */ }
            if (vertices->t == tinyply::Type::FLOAT64) { /* as doubles ... */ }
        }
    }
    catch (const std::exception & e)
    {
        std::cerr << "Caught tinyply exception: " << e.what() << std::endl;
        return -1;
    }
    return 0;
}

int Viewer3D::_loadCameraParameters(){
    if(LOG_VIEWER_3D){cout << "Viewer3D::_loadCameraParameters(): Start...\n";}

    if(_viewerSettings.camParamFile.empty()){
        cerr << "Viewer3D::_loadCameraParameters(): Error on importing Q Matrix!\n";
        return -1;
    }


    // Load the configuration matrix //
    FileStorage fs(_viewerSettings.camParamFile, FileStorage::READ);

    if( !fs.isOpened() ){
        cerr << "Viewer3D::_loadCameraParameters(): Error on opening Camera Extrinsic File" << std::endl;
        return -1;
    }

    fs["Q"] >> _Q;
    fs.release();

    if(_Q.empty()){
        cerr << "Viewer3D::_loadCameraParameters(): Error on reading Q matrix!\n";
        return -1;
    }

    if(LOG_VIEWER_3D){cout << "Viewer3D::_loadCameraParameters(): Finish_OK!\n";}
    return 0;
}

//stereoRectify(left_cam_matrix, left_dist_coeffs, right_cam_matrix, right_dist_coeffs,frame_size, stereo_params.R, stereo_params.T, R1, R2, P1, P2, Q, CALIB_ZERO_DISPARITY, 0, frame_size, 0, 0);

//initUndistortRectifyMap(left_cam_matrix, left_dist_coeffs, R1, P1, frame_size,CV_32FC1, left_undist_rect_map_x, left_undist_rect_map_y);
//initUndistortRectifyMap(right_cam_matrix, right_dist_coeffs, R2, P2, frame_size, CV_32FC1, right_undist_rect_map_x, right_undist_rect_map_y);
//cv::remap(left_frame, left_undist_rect, left_undist_rect_map_x, left_undist_rect_map_y, CV_INTER_CUBIC, BORDER_CONSTANT, 0);
//cv::remap(right_frame, right_undist_rect, right_undist_rect_map_x, right_undist_rect_map_y, CV_INTER_CUBIC, BORDER_CONSTANT, 0);

//cv::Mat imgDisparity32F = Mat( left_undist_rect.rows, left_undist_rect.cols, CV_32F );
//StereoBM sbm(StereoBM::BASIC_PRESET,80,5);
//sbm.state->preFilterSize  = 15;
//sbm.state->preFilterCap   = 20;
//sbm.state->SADWindowSize  = 11;
//sbm.state->minDisparity   = 0;
//sbm.state->numberOfDisparities = 80;
//sbm.state->textureThreshold = 0;
//sbm.state->uniquenessRatio = 8;
//sbm.state->speckleWindowSize = 0;
//sbm.state->speckleRange = 0;

//// Compute disparity
//sbm(left_undist_rect, right_undist_rect, imgDisparity32F, CV_32F );

//// Compute world coordinates from the disparity image
//cv::Mat XYZ(disparity32F.size(),CV_32FC3);
//reprojectImageTo3D(disparity32F, XYZ, Q, false, CV_32F);
//print_3D_points(disparity32F, XYZ);


//cv::Vec3f *StereoFrame::compute_3D_world_coordinates(int row, int col,
//  shared_ptr<StereoParameters> stereo_params_sptr){

// cv::Mat Q_32F;

// stereo_params_sptr->Q_sptr->convertTo(Q_32F,CV_32F);
// cv::Mat_<float> vec(4,1);

// vec(0) = col;
// vec(1) = row;
// vec(2) = this->disparity_sptr->at<float>(row,col);

// // Discard points with 0 disparity
// if(vec(2)==0) return NULL;
// vec(3)=1;
// vec = Q_32F*vec;
// vec /= vec(3);
// // Discard points that are too far from the camera, and thus are highly
// // unreliable
// if(abs(vec(0))>10 || abs(vec(1))>10 || abs(vec(2))>10) return NULL;

// cv::Vec3f *point3f = new cv::Vec3f();
// (*point3f)[0] = vec(0);
// (*point3f)[1] = vec(1);
// (*point3f)[2] = vec(2);

//    return point3f;
//cv::Mat_<cv::Vec3f> _XYZ(disparity32F.rows,disparity32F.cols);   // Output point cloud
//cv::Mat_<float> vec_tmp(4,1);
//for(int y=0; y<disparity32F.rows; ++y) {
//    for(int x=0; x<disparity32F.cols; ++x) {
//        vec_tmp(0)=x; vec_tmp(1)=y; vec_tmp(2)=disparity32F.at<float>(y,x); vec_tmp(3)=1;
//        vec_tmp = Q*vec_tmp;
//        vec_tmp /= vec_tmp(3);
//        cv::Vec3f &point = XYZ.at<cv::Vec3f>(y,x);
//        point[0] = vec_tmp(0);
//        point[1] = vec_tmp(1);
//        point[2] = vec_tmp(2);
//    }
//}
